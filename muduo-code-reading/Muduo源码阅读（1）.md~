# Muduo源码阅读（1）：Reactor模式的意义及产生背景
Muduo是一个基于Reactor模式的非阻塞网络库，所以要理解Muduo的设计必须得先弄清楚什么是Reactor模式。

Reactor模式经常被翻译为“反应器”模式，但我认为这个翻译并不夠直观。其实说白了，所谓react就是对外界事件到来的一种被动的处理。比如在零下的室外环境中，我们会情不自禁的起鸡皮疙瘩，这就是我们对“感到寒冷”这个事件的反应；再比如我们因得知自己中了六合彩而高兴的手舞足蹈，这就是对“中大奖”这个事件的反应；对于软件而言，我们点击了界面上的某个按钮会弹出对话框，弹出对话框当然是对“点击按钮”事件的反应。可以看到，上述几种情形中都不是主动的发出动作，而是因为事件的到来而触发了反应的产生。我们知道，软件的其实是一种对现实生活现象建模，再通过计算机完成求解的过程，而Reactor模式就是针对上面这种现象而提出的。

现在让我们用较专门的语言再来阐述Reactor模式。首先联想一下普通函数调用的机制：程序调用某函数，函数执行，程序等待，函数将结果和控制权返回给程序，程序继续处理[1]。这是一种顺序的处理方式，但Reactor并不主动会调用函数，而是首先将相应的处理函数注册到Reactor上，当我们感兴趣的事件发生到来再通知Reactor调用之前注册的函数完成处理，这些函数就是所谓的“回调函数”，而到来的事件可以多种多样，比如信号、I/O读写、定时、GUI消息等。

回到网络编程，我们处理的其实就是各种各样的事件。服务器接收到客户端的连接、读数据、写数据、接收到错误，这些都是事件。一般的处理都是一种主动调用函数的方式，比如最简单的TCP服务器模型：
```
socket(...);
bind(...);
listen(...);
for ( ; ; ) {
    accept(...);
    if ((childpid = fork()) == 0) {
        ....
    }
}
```
服务器端在完成基本的套接字建立、绑定、监听后，在for循环中主动的调用accept等待客户端连接到来，如果没有新连接，会阻塞在accept上，如果有新连接，则fork出一个子进程用以完成连接的处理。我们知道，随着并发连接的增多，我们需要fork出很多的子进程，当然也有其他的客户/服务器编程范式[2]，比如每一个客户通过一个线程处理。但类似的方式都会带来各种问题[3],比如效率、编程复杂度、移植性等，具体可参考[5]。而Reactor模式在高并发的场景下就有了优势。Reactor模式一般与非阻塞I/O结合，在处理一个事件时不用等待事件的完成，而是转而去处理其他的任务，当这个事件处理完毕后再去通知Reactor，从而用单个线程可以完成多线程才能完成的任务，提高了系统的吞吐量。[4]中用一个餐馆的例子解释了Reactor模式在高并发下的优势，很有意思。具体来说，reactor模式有如下优点[1,3]：
* 响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；
* 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；
* 可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；
* 可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；

[1] [libevent源码深度剖析：Reactor模式](http://cpp.ezbty.org/content/science_doc/libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%9Areactor%E6%A8%A1%E5%BC%8F)

[2] 《Unix Network Programming》 v3 30章

[3] [Reactor by DC Schmidt](www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf‎)

[4] http://daimojingdeyu.iteye.com/blog/828696

[5] [c10k problem](http://www.kegel.com/c10k.html)
